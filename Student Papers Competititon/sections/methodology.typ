= Методологія

== Теоретична частина

У цій роботі запропоновано методологію, натхненну підходами, описаними в @moussaoui_enhancing_2024, @dong_cnn-based_2017 та @laroca_robust_2018. Для детекції транспортних засобів і номерних знаків використовується одноетапна архітектура YOLOv11 @jocher_ultralytics_2023. На момент розробки у 2025 році ця версія була найсучаснішою в сімействі моделей YOLO. На відміну від попередніх ітерацій, YOLOv11 поєднує в собі переваги традиційних згорткових нейронних мереж (CNN) та візуальних трансформерів (_Vision Transformers_, ViT). Це дозволяє забезпечити вищу точність детекції завдяки кращому врахуванню глобального контексту зображення та складних просторових залежностей.

Для розпізнавання тексту використано бібліотеку EasyOCR @noauthor_jaidedaieasyocr_2026, оскільки вона продемонструвала високу ефективність у роботі @moussaoui_enhancing_2024. Крім того, дослідження @smelyakov_effectiveness_2021 підтверджує кращу точність цієї бібліотеки у складних умовах експлуатації порівняно з TesseractOCR @fayez_sirfztesserocr_2026 --- іншим популярним програмним рішенням для задач оптичного розпізнавання символів.

Для підвищення точності OCR застосовуються два етапи попередньої обробки: вирівнювання та бінаризація. Оскільки YOLO виявляє об'єкти за допомогою обмежувальної рамки, пряма ректифікація (як у роботі @dong_cnn-based_2017) є недоступною. Тому було обрано open-source рішення для вирівнювання зображень за однією віссю @mauder_galfardeskew_2026. Цей алгоритм апроксимує базову лінію текстового рядка та вирівнює його горизонтально. Для бінаризації використовуються методи адаптивного порогу з бібліотеки комп'ютерного зору OpenCV @opencv_team_opencv_nodate.

Оскільки запропонована методологія орієнтована на опрацювання статичних зображень, використання механізму часової надмірності (за прикладом @laroca_robust_2018) є неможливим. У зв'язку з цим було розроблено алгоритм постпроцесингу для корекції помилок розпізнавання.

Бібліотека EasyOCR повертає список розпізнаних текстових сегментів та відповідні коефіцієнти впевненості. У деяких випадках, особливо при опрацюванні номерних знаків мотоциклів, система детектує декілька окремих рядків замість одного цілісного. Крім того, через специфіку шрифту українських номерних знаків (згідно з ДСТУ 4278:2019 @DSTU_4278-2019), певні символи є вразливими до взаємної підміни: наприклад, цифра "0" та літера "О", або цифра "1" та літера "І". Для EasyOCR було встановлено поріг впевненості у 0.3 емпіричним шляхом та дало найкращі результати.

#figure(
  image("../figs/PreprocessingDemo.png", width: 70%),
  caption: [Етапи попередньої обробки зображення: вирівнювання та бінаризація.],
)<PreprocessingDemo>

== Програмна реалізація

Програмну частину реалізовано мовою Python 3.12. Як базовий детектор обрано модель YOLOv11n (Nano), що забезпечує мінімальне споживання ресурсів при незначній різниці в точності (mAP) порівняно з більшими конфігураціями.

Навчання здійснювалося в екосистемі _Ultralytics_ із застосуванням косинусного затухання швидкості навчання (_Cosine Learning Rate Scheduler_) та механізму ранньої зупинки (_Early Stopping_) при відсутності покращень протягом 20 епох. Для підвищення стійкості моделі до зовнішніх умов використано вбудовані методи аугментації (зокрема мозаїчне поєднання та масштабування).

Також залучено вбудовані методи аугментації даних. Вони забезпечують автоматичну трансформацію вхідних зображень (масштабування, зміна яскравості, мозаїчне поєднання), що дозволяє підвищити стійкість моделі до варіативності умов знімання та змін зовнішнього середовища.

Для практичної імплементації алгоритму корекції використано стандартні бібліотеки Python для роботи з регулярними виразами (_re_) @python_software_foundation_re_nodate та ітеративними методами (_itertools_) @python_software_foundation_itertools_nodate. Логіку роботи алгоритму наведено в @ErrorCorectionCode[лістингу].

Для валідації розпізнаних символів використано знання про структуру українських номерних знаків. Відповідно до стандарту, загальний формат складається з 8 символів та поділено на 3 логічні сегменти:
- Код регіону --- 2 літери, наприклад "AA" чи "BC";
- Порядковий номер --- 4 цифри від 0001 до 9999;
- Серія --- 2 літери, що визначають серію, наприклад "TO" чи "JA".

Оскільки певні символи мають схоже накреслення, алгоритм застосовує евристичні правила заміни залежно від позиції символу в рядку.

Оскільки в процесі роботи EasyOCR може фрагментувати номерний знак на декілька частин, алгоритм відновлює цілісність рядка шляхом перестановки. Хоча цей підхід має факторіальну часову складність $O(n!)$, де $n$ --- кількість знайдених текстових блоків, у реальних умовах кількість таких фрагментів зазвичай становить $n < 4$. Це робить обчислювальні витрати на перевірку всіх комбінацій незначними порівняно з роботою основної моделі.

#figure(
  caption: [Функції корекції помилок розпізнавання номерних знаків.],
)[
  ```py
  OCR_READER = easyocr.Reader(["en"])
  def extract_text(img):
    res = OCR_READER.readtext(img, allowlist='ABCDEHIKMNOPTXYZJ0123456789|', text_threshold=0.3)
    return [''.join(p) for p in permutations([r[1] for r in res])]

  def correct_chars(text):
    RULES = {
      'outer': {'0':'O','1':'I','8':'B','2':'Z','7':'Z','|':'I'},
      'inner': {'O':'0','I':'1','B':'8','Z':'7','|':'1'}
    }
    c = list(text)
    for i in range(len(c)):
      key = 'outer' if i in [0,1,6,7] else ('inner' if i in [2,3,4,5] else None)
      if key: c[i] = RULES[key].get(c[i], c[i])
    return ''.join(c)

  def error_correct_plate(text):
      PATTERN = r"[A-Z01827\|]{2}[0-9OIBZ\|]{4}[A-Z01827\|]{2}"
      for p in text:
          if not (match := re.search(PATTERN, p)): continue
          corrected = correct_chars(match.group())
          return (True, corrected)
      if not len(text[0]) == 8: return (False, text[0])
      return (False, correct_chars(text[0]))
  ```
]<ErrorCorectionCode>

#figure(
  image("../figs/ErrorCorrectionDemo.png"),
  caption: [Приклад роботи алгоритму виправлення помилок.],
)
